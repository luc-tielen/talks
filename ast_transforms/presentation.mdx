
import { Steps, Step } from "../components/Steps"
import Split from "../layouts/Split"
import Markdown from "react-markdown"
import { dark } from "mdx-deck/themes"
import { Notes } from "mdx-deck"
import nightOwl from "prism-react-renderer/themes/nightOwl"

export { components } from "mdx-deck-code-surfer"
export const theme = {
  ...dark,
  codeSurfer: {
    ...nightOwl,
    showNumbers: false
  }
}

# AST transformations

---

## Table of contents

- Intro + quick recap on ASTs
- AST transformations
- Examples (demo)
- Questions

---

## Structure of a compiler

<Steps>
<Step>![Compiler structure](./images/compiler_structure.svg)</Step>
<Step>![Compiler structure](./images/compiler_structure2.svg)</Step>
</Steps>

---

## Abstract Syntax Trees

![Simple AST](./images/simple_ast.svg)

Expression: 1 + 2 * 3

<Notes>
This is now the level at which we will be focusing for the rest of the talk.
</Notes>

---

## AST transformations

<Split>
  <Markdown>
    ![Before AST transform](./images/ast_transform1.svg)
  </Markdown>
  <Markdown>
    ![After AST transform](./images/ast_transform2.svg)
  </Markdown>
</Split>

<Notes>
- Possible to add / modify / simplify information
- Can optimizing programs using this way
</Notes>

---

## Types of optimizing compilers

<Notes>
Focus on: optimizing
</Notes>

---

### One-pass compiler (the "monolith")

![Normal compiler](./images/normal_compiler.svg)

- Optimizations all at once
- Hard to maintain

---

### Micropass compiler

![Micropass compiler](./images/micropass_compiler.svg)
- Smaller, composable optimizations
- Â± 5-10 transforms

---

### Nanopass compiler

![Nanopass compiler](./images/nanopass_compiler.svg)
- Very small, focused optimizations
- 50+ transforms not uncommon
- Easier to maintain, extend, ...

---

### Examples of compiler passes

- Constant folding
- Dead code elimination
- Curried lambdas / applications
- ...

---

## Desugaring expressions

- So far, focus on optimizations
- Transforms can also be used for "code reuse"
- Rewrite expr1 in terms of expr2

---

## Desugaring expressions (2)

- Examples: Racket
- Code = data, data = code
- Macros: rewrite code on AST level
- Full power of language during compile time

<Notes>
- Lisp mantra: code = data, data = code
- Also called: the programmable programming language
- Full power includes:
  - macros expanding to macros
  - compile time evaluation
  - HTTP requests
  - ...
- Elixir: also some features possible, but more syntax to explain
</Notes>

---

```lisp Examples (1)
42

"abc"

#t  ; also #f

(begin 1 2 3)   ; evaluates to 3

(lambda (x) x)

(define x 5)

(define (identity x)
  x)

(+ 1 2)         ; evaluates to 3

'(+ 1 2)        ; evaluates to (+ 1 2)

`(+ 1 ,x)       ; evaluates to (+ 1 5)

(eval '(+ 1 2)) ; evaluates to 3
-----
1 > numbers
3 > Strings
5 > Booleans
7 > Begin expression
9 > Function definition
11 > Variables
13, 14 > Function definition (using define)
16 > Function application
18 > Quote
20 > Quasiquote / unquote
16:20 > Normal evaluation vs quotation
22 > Evaluation of quoted expressions
```

<Notes>
<p>
- AST looks the same as the code
- Simple structure => extensible syntax
- Special forms: define, lambda, ...
</p>
</Notes>

---

```lisp Examples (2)
(if true
  1
  (display "hello world"))  ; evaluates to 1

(define-syntax-rule
  (unless condition false-clause true-clause)
  (if condition true-clause false-clause))

; prints "hello world"
(unless true
  1
  (display "hello world"))

(define-syntax for
  (syntax-rules ()
    [(for (x) func) (func x)]
    [(for (x y ...) func)
      (begin (func x)
             (for (y ...) func))]))

> (for (1 2 3) displayln)
1
2
3

(define-syntax quoted-for
  (syntax-rules ()
    [(_ (x) func) '(func x)]
    [(_ (x y ...) func)
      `(begin (func x)
             ,(quoted-for (y ...) func))]))

> (quoted-for (1 2 3) displayln)
'(begin (displayln 1)
        (begin (displayln 2)
               (displayln 3)))

(define-syntax quoted-cond
  (syntax-rules ()
    [(quoted-cond [test value])
     `(if test value (void))]
    [(quoted-cond [test value] [test2 value2] ...)
     `(if test value ,(quoted-cond [test2 value2] ...))]))

> (quoted-cond
    [(> 1 x) 1]
    [(> 3 1) 2])
'(if (> 1 x)
   1
   (if (> 3 1)
     2
     (void)))
----
1:3 > If expressions
5:7 > Define-syntax-rule
9:12 > Our own syntax!
14:19 > Loop example
21:24 > In REPL
26:31 > Variant with quotation
33:36> In REPL
38:43 > Multi if example (cond)
45:52 > In REPL
```

<Notes>
<p>
- define-syntax-rule: add custom syntax
- Evaluated at compile time
- Hygienic macros
- multiple rules: slightly more complex
- Many different variations, since syntax-based macros are defined in term of one another
- also possible: cond, assert, ...
- quoted-X versions for easily showing expanded AST
</p>
</Notes>

---

## Conclusion

- Technique of representing code/actions as data is very powerful
- Key: minimal set of operations, compose on top
- Only the tip of the iceberg...

---

## Questions?

![Lisp XKCD](./images/lisp.png)

---

## Links

- [https://github.com/luc-tielen/talks/ast_transforms](https://github.com/luc-tielen/talks/ast_transforms)
- [https://racket-lang.org/](https://racket-lang.org)
- [https://www.youtube.com/watch?v=Os7FE3J-U5Q](https://www.youtube.com/watch?v=Os7FE3J-U5Q)

---

## Next?

- Parser combinators?
- LLVM (code generation)?

